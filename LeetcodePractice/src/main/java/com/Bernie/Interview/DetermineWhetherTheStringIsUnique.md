## LeetCode面试01.01题 判断字符是否唯一
----
>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。
   
**示例 1**：
```text
输入: s = "leetcode"
输出: false 
```

**示例 2：**
```text
输入: s = "abc"
输出: true
```
**限制：**
1. 0 <= len(s) <= 100
2. 如果你不使用额外的数据结构，会很加分。

### 题目解析
由于ASCII码字符个数为128个，而且题目说了`如果你不使用额外的数据结构，会很加分。`因此可以使用两个64位的long变量来存储是否出现某个字符，二进制位1表示出现过， 0表示未出现过。具体代码如下：
```java
public class DetermineWhetherTheStringIsUnique {

    public boolean isUnique(String astr) {
        long low64 = 0,height64=0;
        for (char c : astr.toCharArray()) {
            if (c >= 64) {
                long index = 1L << (c - 64);
                if ((height64 & index) != 0) return false;
                height64 |= index;
            } else {
                long index = 1L << c;
                if ((low64 & index) != 0) return false;
                low64 |= index;
            }

        }
        return true;
    }

    public static void main(String args[]) {
        String s = "abbc";
        System.out.println(new DetermineWhetherTheStringIsUnique().isUnique(s));
    }
}
```
### 题目延伸
> 本题说不使用额外的数据结构，会很加分，主要考察位运算符

Java中的基础字节的长度是一致的，列出以下基本类型的长度如下
```text
int：4 个字节。

short：2 个字节。

long：8 个字节。

byte：1 个字节。

float：4 个字节。

double：8 个字节。

char：2 个字节。

boolean：boolean属于布尔类型，在存储的时候不使用字节，仅仅使用 1 位来存储，范围仅仅为0和1，其字面量为true和false。
```

下面介绍Java的位运算符([参考博客](https://blog.csdn.net/briblue/article/details/70296326))

#### & 与运算符
**规则** 与运算时，进行运算的两个数，从最低位到最高位，一一对应。如果某 bit 的两个数值对应的值只要 1 个为 1，则结果值相应的 bit 就是 1，否则为 0。
```text
0 | 0 = 0,

0 | 1 = 1,

1 | 1 = 1
```
3 | 5 = 7 这是因为
```text
0000 0011
|
0000 0101
=
0000 0111
```

#### ~ 取反运算符
**规则** 对操作数的每一位进行操作，1 变成 0，0 变成 1。
```
~5 =>  0000 0101   ~  => 1111 1010
```

#### ^ 异或运算符
**规则** 两个操作数进行异或时，对于同一位上，如果数值相同则为 0，数值不同则为 1。
```
1 ^ 0 = 1,

1 ^ 1 = 0,

0 ^ 0 = 0;
```
值得注意的是 3 ^ 5 = 6,而 6 ^ 5 = 3
```
0000 0110
|
0000 0101
=
0000 0011
```

#### >> 右移运算符
**规则** a >> b 将数值 a 的二进制数值从 0 位算起到第 b - 1 位，整体向右方向移动 b 位，符号位不变，高位空出来的位补数值 0。
```
5 >> 1 ===>  1000 0000 0000 0101 >> 1  = 1000 0000 0000 0010 = 2
7 >> 2 ===>  1000 0000 0000 0111 >> 2  = 1000 0000 0000 0001 = 1
9 >> 3 ===>  1000 0000 0000 1001 >> 3  = 1000 0000 0000 0001 = 1
11 >> 2 ===> 1000 0000 0000 1011 >> 2 = 1000 0000 0000 0010 = 2
```

#### << 左移运算符
**规则** a << b 将数值 a 的二进制数值从 0 位算起到第 b - 1 位，整体向左方向移动 b 位，符号位不变，低位空出来的位补数值 0。
```
5 << 1 ===>  1000 0000 0000 0101 << 1  = 1000 0000 0000 1010 = 10
7 << 2 ===>  1000 0000 0000 0111 << 2  = 1000 0000 0001 1100 = 28
9 << 3 ===>  1000 0000 0000 1001 << 3  = 1000 0000 0100 1000 = 72
11 << 2 ===> 1000 0000 0000 1011 << 2 = 1000 0000 0010 1100 = 44
```

综合上面两个可以看到，如果某个数值右移 n 位，就相当于拿这个数值去除以 2 的 n 次幂。如果某个数值左移 n 位，就相当于这个数值乘以 2 ^ n。